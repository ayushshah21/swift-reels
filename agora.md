Below is a step-by-step guide on how you could **integrate the Agora RTC SDK** into your existing SwiftUI + Firebase architecture to enable live streaming (broadcasting and viewing). This answer provides:

1. **Project & Dependency Setup**  
2. **High-Level Architecture**  
3. **Creating a Live Session** (Broadcaster flow)  
4. **Joining a Live Session** (Viewer flow)  
5. **Managing Live Session Data in Firestore**  
6. **Example Code**:  
   - **AgoraManager** (Singleton to manage Agora engine setup)  
   - **LiveStreamView** (SwiftUI view that embeds the broadcaster/viewer video)  
   - **LiveSession** model (how you might structure Firestore data)  

---

## 1. Project & Dependency Setup

1. **Install Agora RTC SDK**  
   - **Swift Package Manager** (recommended):  
     1. In Xcode, go to **File > Add Packages**.  
     2. Enter the package URL:  
        ```
        https://github.com/AgoraIO-Community/AgoraIO-Swift-Package
        ```
     3. Select **AgoraRtcEngine_iOS** and add it to your project.
   
   - **CocoaPods** (alternative):  
     1. In your `Podfile`:  
        ```ruby
        pod 'AgoraRtcEngine_iOS'
        ```  
     2. Run `pod install`.
   
2. **Import Agora** in Swift files where needed:
   ```swift
   import AgoraRtcKit
   import AgoraRtcEngine_iOS // if using SwiftPM
   ```
3. **Configure Permissions** in your app‚Äôs Info.plist (for camera & microphone):
   ```xml
   <key>NSCameraUsageDescription</key>
   <string>Allow access to camera for live streaming</string>
   <key>NSMicrophoneUsageDescription</key>
   <string>Allow access to microphone for live streaming</string>
   ```
4. **Add the required entitlements** if your live streaming also uses background modes, etc. (e.g., `audio` if you want background audio).  

---

## 2. High-Level Architecture

You already have a well-structured codebase with managers (e.g., `StorageManager`, `FirestoreManager`) and SwiftUI views. To introduce **live streaming**:

1. **LiveSession**: A Firestore document representing a live broadcast session (channelId, host userId, active state, viewers, etc.).  
2. **AgoraManager**: A new singleton manager class (similar to `FirestoreManager`) that initializes the Agora engine, handles joining/leaving channels, and manages local/remote video feeds.  
3. **LiveStreamView**: A SwiftUI view that uses `UIViewControllerRepresentable` to wrap the `AgoraRtcEngineKit` usage in a custom `UIViewController`. You can also embed the host‚Äôs or viewer‚Äôs camera feed.  
4. **Creation Flow (Broadcaster)**: A user taps ‚ÄúGo Live‚Äù ‚Üí A new `LiveSession` doc is created in Firestore ‚Üí The broadcaster‚Äôs device joins the Agora channel ‚Üí UI shows the broadcaster‚Äôs camera preview.  
5. **Discovery & Join Flow (Viewer)**: Other users see a ‚ÄúLive‚Äù item in the feed or a dedicated ‚ÄúLive‚Äù tab ‚Üí Tapping it retrieves the `LiveSession` doc + channelId ‚Üí The viewer‚Äôs device joins the channel in ‚Äúaudience‚Äù mode ‚Üí UI shows both the broadcaster‚Äôs video and any other published streams.  

---

## 3. Creating a Live Session (Broadcaster Flow)

### a) Firestore Document

When a user taps ‚ÄúGo Live,‚Äù create a new document in `liveSessions` collection:
```swift
struct LiveSession: Codable, Identifiable {
    let id: String
    let hostId: String
    let hostName: String
    let channelId: String
    var isActive: Bool
    var createdAt: Date
    
    // Possibly track viewers, etc.
    var viewerCount: Int
    var viewers: [String]
    
    // Firestore encoding/decoding, etc.
}

// Example Firestore schema (liveSessions/{sessionId}):
// {
//   "id": "auto-generated by Firestore",
//   "hostId": "UID of the broadcaster",
//   "hostName": "Display name of broadcaster",
//   "channelId": "Agora channel name / ID",
//   "isActive": true,
//   "createdAt": Timestamp(...),
//   "viewerCount": 0,
//   "viewers": []
// }
```

### b) Create & Store Session

```swift
func createLiveSession(for user: User) async throws -> LiveSession {
    let channelId = UUID().uuidString // or any unique string
    let session = LiveSession(
        id: "", // let Firestore auto-generate or use channelId
        hostId: user.id,
        hostName: user.username,
        channelId: channelId,
        isActive: true,
        createdAt: Date(),
        viewerCount: 0,
        viewers: []
    )
    
    // Save in Firestore (pseudo-code)
    let docRef = try await db.collection("liveSessions").addDocument(from: session)
    // Once we get the docRef, store docRef.documentID in session.id
    return session
}
```

### c) Start Broadcasting with Agora

Once the session is created, you have the `channelId`. The broadcaster calls:
```swift
await AgoraManager.shared.startBroadcasting(channelId: session.channelId)
```
This sets up the local camera/mic and publishes the stream to that channel.

---

## 4. Joining a Live Session (Viewer Flow)

For viewers:

1. **Fetch** an active `LiveSession` from Firestore (either from a list or direct link).
2. **Join** using the `channelId` from that session:
   ```swift
   await AgoraManager.shared.joinChannel(channelId: session.channelId)
   ```
3. **View** remote streams; do not publish your camera if you only want an audience.

---

## 5. Managing Live Session Data in Firestore

- **Real-time listener** on `liveSessions` collection to get active sessions for a feed or a ‚ÄúLive‚Äù tab.  
- Update `viewerCount` in Firestore by adding a small `incrementViewers` / `decrementViewers` transaction when a user joins/leaves.  
- When the broadcaster ends the session, set `isActive = false` and remove from the feed.  

Example of ending a session:
```swift
func endLiveSession(_ session: LiveSession) async throws {
    try await db.collection("liveSessions").document(session.id).updateData([
        "isActive": false
    ])
    
    // Also tell Agora to leave channel
    await AgoraManager.shared.leaveChannel()
}
```

---

## 6. Example Code

### A) AgoraManager

Below is a simplified `AgoraManager` class. You can expand it (e.g., with delegate callbacks, token handling, error logging, etc.):

```swift
import AgoraRtcKit
import SwiftUI

@MainActor
class AgoraManager: NSObject, ObservableObject {
    static let shared = AgoraManager()

    private var engine: AgoraRtcEngineKit?
    private let appId = "<#Your Agora App ID#>"
    
    // If you are using a temporary token or a token server:
    private let tempToken = "<#Optional: Your Temporary Token#>"
    
    // Store the current channel ID to handle leaving, etc.
    private var currentChannel: String?

    private override init() {
        super.init()
        setupEngine()
    }
    
    private func setupEngine() {
        // Initialize the Agora engine
        engine = AgoraRtcEngineKit.sharedEngine(withAppId: appId, delegate: self)
        
        // Enable video module
        engine?.enableVideo()
        
        // Set channel profile to live broadcasting
        engine?.setChannelProfile(.liveBroadcasting)
    }
    
    /// Broadcaster joins channel to publish stream
    func startBroadcasting(channelId: String) async {
        guard let engine = engine else { return }

        // Set user role to broadcaster
        engine.setClientRole(.broadcaster)
        
        // Join channel
        let result = engine.joinChannel(byToken: tempToken, channelId: channelId, info: nil, uid: 0) { (channel, uid, elapsed) in
            print("‚úÖ Broadcaster joined channel: \(channel) with uid: \(uid)")
        }
        
        if result != 0 {
            print("‚ùå Error joining channel as broadcaster, code: \(result)")
        } else {
            currentChannel = channelId
        }
    }
    
    /// Audience joins channel to view stream
    func joinChannel(channelId: String) async {
        guard let engine = engine else { return }
        
        // Set user role to audience
        engine.setClientRole(.audience)
        
        let result = engine.joinChannel(byToken: tempToken, channelId: channelId, info: nil, uid: 0) { (channel, uid, elapsed) in
            print("‚úÖ Viewer joined channel: \(channel) with uid: \(uid)")
        }
        
        if result != 0 {
            print("‚ùå Error joining channel as audience, code: \(result)")
        } else {
            currentChannel = channelId
        }
    }
    
    /// Leave the channel
    func leaveChannel() {
        engine?.leaveChannel(nil)
        currentChannel = nil
        print("üëã Left channel.")
    }
}

// MARK: - AgoraRtcEngineDelegate
extension AgoraManager: AgoraRtcEngineDelegate {
    // Called when another user published a stream
    func rtcEngine(_ engine: AgoraRtcEngineKit, didJoinedOfUid uid: UInt, elapsed: Int) {
        print("üë• Remote user joined with uid: \(uid)")
    }

    // Called when remote user leaves
    func rtcEngine(_ engine: AgoraRtcEngineKit, didOfflineOfUid uid: UInt, reason: AgoraUserOfflineReason) {
        print("üë§ Remote user left with uid: \(uid)")
    }
}
```

### B) LiveStreamView (SwiftUI)

We‚Äôll create a SwiftUI view that displays local (broadcaster) or remote (viewer) video. Because Agora provides a UIKit-based video view, we‚Äôll wrap it using `UIViewRepresentable`.

**Broadcaster** code might look like:

```swift
import SwiftUI
import AgoraRtcKit

struct LiveStreamView: View {
    let channelId: String
    let isBroadcaster: Bool
    
    @Environment(\.dismiss) private var dismiss
    @State private var localCanvas = AgoraRtcVideoCanvas()
    @State private var remoteCanvas = AgoraRtcVideoCanvas()
    
    // Track if user has joined
    @State private var hasJoinedChannel = false
    
    var body: some View {
        ZStack {
            // Show local video if broadcaster
            if isBroadcaster {
                AgoraVideoView(canvas: $localCanvas)
                    .ignoresSafeArea()
            } else {
                // Show remote video if viewer
                AgoraVideoView(canvas: $remoteCanvas)
                    .ignoresSafeArea()
            }
            
            VStack {
                HStack {
                    Button("Close") {
                        endSession()
                    }
                    .padding()
                    Spacer()
                }
                Spacer()
            }
        }
        .onAppear {
            Task {
                if isBroadcaster {
                    // Start broadcast
                    await AgoraManager.shared.startBroadcasting(channelId: channelId)
                } else {
                    // Join channel as viewer
                    await AgoraManager.shared.joinChannel(channelId: channelId)
                }
                
                hasJoinedChannel = true
            }
        }
        .onDisappear {
            AgoraManager.shared.leaveChannel()
        }
    }
    
    private func endSession() {
        // If broadcaster, also update Firestore that session is ended
        // ...
        dismiss()
    }
}

// MARK: - AgoraVideoView
/// A UIViewRepresentable that attaches an AgoraRtcVideoCanvas to display video feed
struct AgoraVideoView: UIViewRepresentable {
    @Binding var canvas: AgoraRtcVideoCanvas
    
    func makeUIView(context: Context) -> UIView {
        let view = UIView(frame: .zero)
        view.backgroundColor = .black
        
        // Attach the canvas
        canvas.view = view
        canvas.renderMode = .hidden
        
        // If you want to set up local or remote user:
        // For local, uid is 0 and you set .broadcaster role
        // For remote, you'll set the remote UID from didJoinedOfUid / delegate
        return view
    }
    
    func updateUIView(_ uiView: UIView, context: Context) {
        // No updates needed, unless you want to switch from local to remote
    }
}
```

#### Determining Remote UID

In a real app, you‚Äôll need to know the remote user‚Äôs `uid` from the delegate callback `didJoinedOfUid`. Then you set up a separate canvas. For instance, if you want to show the broadcaster‚Äôs video on the viewer side:

```swift
extension AgoraManager: AgoraRtcEngineDelegate {
    func rtcEngine(_ engine: AgoraRtcEngineKit, didJoinedOfUid uid: UInt, elapsed: Int) {
        print("üë• Remote user joined with uid: \(uid)")
        
        // Example: If you want to automatically render the first remote user‚Äôs stream:
        let remoteCanvas = AgoraRtcVideoCanvas()
        remoteCanvas.uid = uid
        remoteCanvas.renderMode = .hidden
        remoteCanvas.view = someSwiftUIHostedUIView
        engine.setupRemoteVideo(remoteCanvas)
    }
}
```

You might store that remoteCanvas in an `@StateObject` or `@Published` property so SwiftUI can update the UI.

### C) Integrate with Your Existing Code

1. **Go Live Button** in `ProfileView` or any place:
   ```swift
   Button("Go Live") {
       Task {
           guard let currentUser = try? await firestoreManager.getUser(id: Auth.auth().currentUser?.uid ?? "") else { return }
           
           do {
               // Create a live session
               let session = try await createLiveSession(for: currentUser)
               
               // Navigate to LiveStreamView
               // If using NavigationStack:
               navigationPath.append(Route.live(session: session))
               // Or present a sheet:
               // sheetPresented = true with session info
           } catch {
               print("‚ùå Error creating live session: \(error)")
           }
       }
   }
   ```
2. **Show LiveStreamView**:
   ```swift
   .sheet(isPresented: $sheetPresented) {
       LiveStreamView(channelId: session.channelId, isBroadcaster: true)
   }
   ```
3. **Discover Active Sessions** in `ReelsFeedView` or new `LiveSessionsView`:
   ```swift
   // In FirestoreManager
   func getActiveLiveSessions() async throws -> [LiveSession] {
       let snapshot = try await db.collection("liveSessions")
           .whereField("isActive", isEqualTo: true)
           .getDocuments()
       return snapshot.documents.compactMap { try? $0.data(as: LiveSession.self) }
   }

   // UI side
   .task {
       do {
           let sessions = try await firestoreManager.getActiveLiveSessions()
           // Display them in a list
       } catch { ... }
   }
   ```
4. **Join as Viewer**:  
   When tapping on a listed live session:
   ```swift
   NavigationLink(destination: LiveStreamView(channelId: session.channelId, isBroadcaster: false)) {
       Text("Join \(session.hostName)'s Live")
   }
   ```

---

# Summary

By adding an **AgoraManager** and a new **LiveStreamView**, you can enable real-time livestreaming in your SwiftUI + Firebase app. The **core steps** are:

1. **Install and initialize Agora**.  
2. **Store session metadata** (channelId, host info) in Firestore.  
3. **Broadcaster** calls `startBroadcasting()` with a unique channelId.  
4. **Viewers** call `joinChannel()` using that same channelId.  
5. **Listen to events** (user joined/left) via `AgoraRtcEngineDelegate`.  
6. **End session** by calling `leaveChannel()` and marking Firestore session as inactive.

With this approach, you can expand your existing feed-based app to list live sessions alongside or in a dedicated tab, handle real-time chat or interactions (using Firestore real-time listeners or Agora RTM), and give your users the ability to broadcast or watch workout sessions live.

---

**Next Steps & Enhancements**:
- **Token Security**: In production, you should generate an Agora token on a **secure server** (instead of a hardcoded `tempToken`) to prevent unauthorized channel access.  
- **Remote Video Layout**: For multiple viewers or multi-host live sessions, you can manage multiple remote canvas views.  
- **Real-Time Chat**: Use **Agora RTM** or a Firestore subcollection for chat messages.  
- **UI Customization**: Display host‚Äôs camera in a smaller PiP window for viewers, show concurrent viewer count, etc.

With these foundations, you can build a robust livestreaming experience within your SwiftUI + Firebase application. Good luck, and happy coding!